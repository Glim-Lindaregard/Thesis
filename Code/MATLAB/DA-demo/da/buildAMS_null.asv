function AMS = buildAMS_null(A, umin, umax)
% BUILDAMS_NULL  AMS via null-space/partition (per paper's post row-space description).
% -------------------------------------------------------------------------
% INPUTS
%   A     : 3×m, rank 3 (control effectiveness)
%   umin  : m×1 lower bounds
%   umax  : m×1 upper bounds
%
% OUTPUT (minimal, row-space-free)
%   AMS.A, AMS.umin, AMS.umax
%   AMS.S0, AMS.F0, AMS.Xi  : a null-space basis from a well-conditioned 3×3
%   AMS.pairs               : all unordered actuator pairs (i,j)
%   AMS.facets(k) with fields:
%       .ij         : [i j]
%       .locktype   : 'max' or 'min'   (as in eqs. (5)–(8))
%       .vertsU     : 4×m control vertices [A;B;C;D]
%       .vertsTau   : 4×3 moment vertices  [A;B;C;D]
%
% Notes:
% - Locking follows (5)–(6): sign( det[ c_i c_j c_k ] ) picks u_k ∈ {umin_k,umax_k}.
% - Vertices are formed by setting (u_i,u_j) ∈ {min,max}² and solving basics from a 3×3.
%
% References: AMS facet locking rules (5)–(8) and linear combination structure of facets. :contentReference[oaicite:1]{index=1}

[rows,m] = size(A);
assert(rows==3,'A must be 3×m');  umin = umin(:);  umax = umax(:);
assert(isvector(umin)&&isvector(umax)&&numel(umin)==m&&numel(umax)==m);

% --- 1) Choose a well-conditioned 3×3 (for Xi only; not used to build facets)
triples = nchoosek(1:m,3);
bestS = []; bestCond = Inf;
for r = 1:size(triples,1)
    S = triples(r,:);
    cnd = cond(A(:,S));
    if isfinite(cnd) && cnd < bestCond, bestCond = cnd; bestS = S; end
end
S0 = bestS; F0 = setdiff(1:m,S0);

% --- 2) Build a null-space basis Xi (columns span ker(A))
Xi = zeros(m,numel(F0)); AS0 = A(:,S0);
for k = 1:numel(F0)
    f = F0(k);
    xiS = -(AS0 \ A(:,f));
    v = zeros(m,1); v(S0)=xiS; v(f)=1;
    Xi(:,k) = v;
end

% --- 3) Facet construction in null-space/partition form (no normals)
pairs = nchoosek(1:m,2);
K = size(pairs,1);
facets(2*K) = struct(); fidx = 0;

% Small helpers
det_sign = @(i,j,k) sign(det([A(:,i), A(:,j), A(:,k)])); % = sign( (c_i×c_j)·c_k )
set_ij   = @(u,i,j,ui,uj) (u(i)=ui, u(j)=uj, u);          % assign ui,uj (inline style)

    for p = 1:K
        i = pairs(p,1); j = pairs(p,2);
    
        % --- pick a basic triple S (invertible) that EXCLUDES i,j; choose best-conditioned
        candS = nchoosek(setdiff(1:m,[i j]),3);
        bestS = []; bestC = Inf;
        for t = 1:size(candS,1)
            S = candS(t,:);
            cnd = cond(A(:,S));
            if isfinite(cnd) && cnd < bestC, bestC = cnd; bestS = S; end
        end
        S = bestS; AS = A(:,S);
        NB = setdiff(1:m,S);    % non-basic indices for this facet
    
        % --- Locking rules (eqs. (5)–(6)) using det signs, no cross products stored
        s = zeros(m,1);
        for k = 1:m
            if k==i || k==j, s(k)=0; else, s(k)=det_sign(i,j,k); end
        end
        base_max = umin; base_max(s>0) = umax(s>0);  % Ω_max,ij in (5)
        base_min = umin; base_min(s<0) = umax(s<0);  % Ω_min,ij in (6)
    
        % Vertex builder: solve basics so that A*u is consistent at the corners
        function [U4,T4] = build_vertices(base)
            % Corners: A(min,min), B(max,min), C(max,max), D(min,max)
            pairs_ij = [umin(i) umin(j);
                        umax(i) umin(j);
                        umax(i) umax(j);
                        umin(i) umax(j)];
            U4 = zeros(4,m); T4 = zeros(4,3);
            for vv = 1:4
                u = base;
                u(i) = pairs_ij(vv,1);  u(j) = pairs_ij(vv,2);
    
                % Solve basics:  A_S u_S = - sum_{k∉S} A_k u_k
                rhs = -A(:,setdiff(1:m,S))*u(setdiff(1:m,S));
                uS  = AS \ rhs;
                u(S)= uS;
    
                U4(vv,:) = u.';
                T4(vv,:) = (A*u).';
            end
        end
    
        % f_max,ij
        [U4,T4] = build_vertices(base_max);
        fidx = fidx+1;
        facets(fidx).ij = [i j]; facets(fidx).locktype = 'max';
        facets(fidx).vertsU = U4; facets(fidx).vertsTau = T4;
    
        % f_min,ij
        [U4,T4] = build_vertices(base_min);
        fidx = fidx+1;
        facets(fidx).ij = [i j]; facets(fidx).locktype = 'min';
        facets(fidx).vertsU = U4; facets(fidx).vertsTau = T4;
    end

AMS = struct('A',A,'umin',umin,'umax',umax, ...
             'S0',S0,'F0',F0,'Xi',Xi, ...
             'pairs',pairs,'facets',facets);
